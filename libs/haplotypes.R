## Functions to extract shared haplotypes from genotype data using f2 variants.

########################################################################################################
## Find all the shared haplotypes given genotypes and f2s
## f1.file: list of f1 variants generated by calculate_fn_sites.py
## f2.file: list of f2 variants generated by calculate_fn_sites.py
## pos.file: variant positions
## by.sample.gt.root: path to the directory which has the per-sample genotype files
## population: restrict to this population
## map: genetic map
## chr: chromosome
########################################################################################################

find.haplotypes.from.f2.vector <- function( pos.lim, f1.file, f2.file, pos.file, by.sample.gt.root, pop.map, map.file, chr=0, verbose=FALSE  ){
    return( find.haplotypes.from.f2( f1.file, f2.file, pos.file, by.sample.gt.root, pop.map, map.file, chr=chr, pos.lim=pos.lim, verbose=verbose ))
}

find.haplotypes.from.f2 <- function( f1.file, f2.file, pos.file, by.sample.gt.root, pop.map,map.file, chr=0, pos.lim=c(0, Inf), verbose=FALSE  ){
  f2 <- load.fn(f2.file)
  f1 <- load.fn(f1.file)
  pos <- scan(pos.file, quiet=TRUE)
  haplen <- length(pos)

  mapfn <- get.mapfn(map.file)

  ## Set up other columns
  f2$chr <- chr
  f2$hap.len <- 0
  f2$hap.left <- 0
  f2$hap.right <- 0
  f2$f1 <- 0
  f2$f2 <- 0
  f2$map.len <- 0

  ## restrict to population and position
  f2 <- f2[f2$pos>=pos.lim[1] & f2$pos<pos.lim[2],]
  f2 <- f2[order(f2$ID1,f2$ID2),]
  
  number.f2 <- NROW(f2)
  if(number.f2==0){return(f2)}
  
  last.ibd.pos=c(-1,-1)
  last.ID.to=-1
  last.ID.from=-1

  for(i in 1:number.f2){
    if(verbose){cat(paste("\rChr", chr, " (", i, "/", number.f2,") ", sep=""))}
    this.pos <- f2$pos[i]
    this.ID.to <- f2$ID1[i]
    this.ID.from <- f2$ID2[i]

    #skip if f2 in single indiviudal.
    if(this.ID.from==this.ID.to){next}
    #skip if still in the previous chunk - relies on the data being odered as above
    if(this.pos<last.ibd.pos[2] & this.ID.to==last.ID.to & this.ID.from==last.ID.from){next}       

    ## Lazy load data - this means that we only load each from genotype once, since they are sorted.
    if(this.ID.from!=last.ID.from){
        from.hap.file <- paste( by.sample.gt.root, "/", names(pop.map)[this.ID.from], ".gt.gz", sep ="")
        from.hap <- scan(from.hap.file, nmax=haplen, quiet=TRUE)
    }
    if(this.ID.to!=last.ID.to){
      to.hap.file <- paste( by.sample.gt.root, "/", names(pop.map)[this.ID.to], ".gt.gz", sep ="")
      to.hap <- scan(to.hap.file, nmax=haplen, quiet=TRUE)
    }
    
    ibd <- find.inconsistent.hom(from.hap, to.hap, pos, this.pos, haplen)
    ibd.pos <- pos[ibd]
    hap.len <- ibd.pos[2]-ibd.pos[1]

    ## Note here for doubletons, we really mean >/< rather than >=/<=. However since the breakpoints are inconsistent homozygotes
    ## they can't be consistent doubletons so it doesn't matter and >/< handles the case where the f2 is at the end of the chrom. 
    singletons <- NROW(f1[(f1$ID1==this.ID.from|f1$ID1==this.ID.to) & f1$pos>ibd.pos[1] & f1$pos<ibd.pos[2],])
    which.doubletons <- f2[((f2$ID1==this.ID.from&f2$ID2==this.ID.to)|(f2$ID2==this.ID.from&f2$ID1==this.ID.to)) & f2$pos>=ibd.pos[1] & f2$pos<=ibd.pos[2],]
    doubletons <- NROW(which.doubletons)
    if(max( which.doubletons$pos ) > pos.lim[2]){
        doubletons <- -1
    }
    
    f2$hap.len[i] <- hap.len
    f2$hap.left[i] <- ibd.pos[1]
    f2$hap.right[i] <- ibd.pos[2]
    f2$f1[i] <- singletons
    f2$f2[i] <- doubletons
    f2$map.len[i] <- (mapfn[ibd.pos[2], "y"]-mapfn[ibd.pos[1], "y"])/100
    
    last.ID.from <- this.ID.from
    last.ID.to <- this.ID.to
    last.ibd.pos <- ibd.pos
  }

  ## Exclude samples which either hit the ends of the chromosome, or which have 0 length
  ## or which have doubletons to the left of the max position. 
  exclude <- (f2$hap.len==0) | (f2$hap.right==max(pos)) | (f2$hap.left==min(pos)) | (f2$f2==-1)
  
  return(f2[!exclude,])
}

########################################################################################################
## Find all the shared haplotypes given genotypes and fns
## should reduce to find.haplotypes.from.f2 at some point, but we may need to
## keep unmerged depending on the data structures
## fn.file: list of f1 variants generated by calculate_fn_sites.py
## pos.file: variant positions
## by.sample.gt.root: path to the directory which has the per-sample genotype files
## population: restrict to this population
## map: genetic map
## chr: chromosome
########################################################################################################

find.haplotypes.from.fn <- function( fn.file, pos.file, by.sample.gt.root, pop.map, population=NA, map.file, chr=0, verbose=FALSE  ){
  fn <- load.fn(fn.file)
  n <- NCOL(fn)-1
  pos <- scan(pos.file, quiet=TRUE)
  haplen <- length(pos)

  mapfn <- get.mapfn(map.file)
    
  fn <- fn[pop.map[fn$ID1]==population|pop.map[fn$ID2]==population,]
  fn <- fn[order(fn$ID1,fn$ID2),]

  number.fn <- NROW(fn)
  dummy <- rep(0,number.fn)
  results <- data.frame(pos=dummy, hap.left=dummy, hap.right=dummy, hap.len=dummy, map.len=dummy)
  result.ids <- data.frame(a=rep(-1, number.fn))
  for(i in 2:n){
    result.ids <- cbind(result.ids, rep(-1, number.fn))
  }
  names(result.ids) <- paste0("ID", 1:n)
  
  n.comp <- n*(n-1)/2
  
  last.ibd.pos <- c(-1,-1)
  last.ids <- c(-1,-2)
  for(i in 1:number.fn){
    if(verbose){cat(paste("\rChr", chr, " (", i, "/", number.fn,") ", sep=""))}
    this.pos <- fn$pos[i]
    these.ids <- fn[i,2:(n+1)]

    #skip if fn in single indiviudal.
    if(any(duplicated(c(these.ids)))){next}
    #skip if still in the previous chunk - relies on the data being odered as above
    if(this.pos<last.ibd.pos[2] & this.pos>last.ibd.pos[1] & any(duplicated(c(these.ids, last.ids)))){
      next    }       
    these.ibds <- matrix(0,nrow=n.comp, ncol=2)
    i.comp <- 1
    for(i1 in 1:(n-1)){
      for(i2 in (i1+1):n){
        from.hap.file <- paste0( by.sample.gt.root, "/", names(pop.map)[these.ids[1,i1]], ".gt.gz")
        from.hap <- scan(from.hap.file, nmax=haplen, quiet=TRUE)
        to.hap.file <- paste0( by.sample.gt.root, "/", names(pop.map)[these.ids[1,i2]], ".gt.gz")
        to.hap <- scan(to.hap.file, nmax=haplen, quiet=TRUE)
        these.ibds[i.comp,] <- find.inconsistent.hom(from.hap, to.hap, pos, this.pos, haplen)
        i.comp <- i.comp+1
      }
    }

    
    ibd <- c(max(these.ibds[,1]), min(these.ibds[,2]))
    ibd.pos <- pos[ibd]
    hap.len <- ibd.pos[2]-ibd.pos[1]
    map.len <- (mapfn(ibd.pos[2])-mapfn(ibd.pos[1]))/100

    results[i,] <- c(this.pos, ibd.pos, hap.len, map.len)
    result.ids[i,] <- these.ids
    
    last.ids <- these.ids
    last.ibd.pos <- ibd.pos
  }

  results <- cbind(results, result.ids)
  exclude <- (results$hap.len==0) | (results$hap.right==max(pos)) | (results$hap.left==min(pos))
  
  return(results[!exclude,])
}

########################################################################################################
## Count the number of singletons between two positions. Really only used for testing
## IDS: two columns of sample IDS
## starts, ends: columns of start and end positions.
## f1.file: list of f1 variants generated by calculate_fn_sites.py
########################################################################################################

count.singletons.from.positions <- function(IDS, starts, ends, f1.file){
  f1 <- load.fn(f1.file)

  S <- rep(0, length=length(starts))
  for(i in 1:length(starts)){
    S[i] <- sum((f1$ID1==IDS[i,1]|f1$ID1==IDS[i,2]) & (f1$pos>starts[i] & f1$pos<ends[i]))
  }
  return(S)
}

########################################################################################################
## Given two haplotypes and an index, find the indices of the first
## inconsistent homozygotes, to the left and the right of pos
## gt1, gt2: genotype vectors
## gt.pos: variant positions
## pos: position to check
########################################################################################################

find.inconsistent.hom <- function(gt1, gt2, gt.pos, pos, len=length(gt1)){
  idx.l <- max(1,findInterval(pos, gt.pos))
  idx.r <- idx.l+1
  if(gt.pos[idx.l]==pos){idx.r <- idx.l}

  idx.l <- max(1,idx.l-1)
  while(idx.l>1 & !((gt1[idx.l]==0 & gt2[idx.l]==2)|(gt1[idx.l]==2 & gt2[idx.l]==0))){
    idx.l <- idx.l-1
  }
  idx.r <- min(len, idx.r+1) 
  while(idx.r<len & !((gt1[idx.r]==0 & gt2[idx.r]==2)|(gt1[idx.r]==2 & gt2[idx.r]==0))){
    idx.r <- idx.r+1
  }
  return(c(idx.l, idx.r))
}

########################################################################################################
## Load the fn file generated with calculate_fn_sites.py
## first column in position and the next n columns are the indices
## of the samples which share those variants. These are haplotype
## samples, so we divide the indexes by two. Also convert from
## 0 to 1-based indexing, assuming that the python output is 0-based. 
########################################################################################################

load.fn <- function(fn.file){
  fn <- read.table(fn.file, as.is=TRUE, header=FALSE)
  idx.range <- 2:length(fn)

  fn[,idx.range] <- fn[,idx.range]+1                  #0 based -> 1 based
  colnames(fn) <- c("pos", paste( "ID", idx.range-1, sep=""))
  ## Convert IDs to (genotype) sample indices
  fn[,idx.range] <- ceiling(fn[,idx.range]/2)
  return(fn)
}

########################################################################################################
## load the recombination map. If it's a number, make that the constant rate, in cM/Mb
## if it's a file, load the map.
########################################################################################################

get.mapfn <- function(map.file){
  mapfn <- NULL
  #if(!is.numeric(map.file)){
    map <- read.table(map.file, as.is=TRUE, header=TRUE)
  #  mapfn <- approxfun(map$Position.bp. , map$Map.cM. , rule=2, method="linear")
  #} else{
  #  r <- as.numeric(map)
  #  mapfn <- approxfun(c(0, 1e9), c(0,r*1e3), rule=1, method="linear") #only going up to 1cm, but rule=1 ensure NA outside this. 
  #}
  map = map %>% dplyr::select(position, Genetic_Map.cM.) %>% rename(x = position, y = Genetic_Map.cM.)
  return(map)
}

########################################################################################################
## From a set of sample genotypes, sample pairs at random, then sample points at
## random, then get the left and right distance to the nearest incompatible hom
## and finally, fit a gamma distribution to the distribution of total distances.
## path.to.samples: path to genotype files
## samples: file list of sample names
## map.file: genetic map
## pairs, each: sample each points from pairs sets of individuals
## verbose: report progress
## direction: either count randomly left or right and then double the distribution, or count both
## ways and estimate the total. These give different answers because the results are correlated. 
########################################################################################################

fit.gamma.to.error <- function(path.to.samples, map.file, samples1, samples2=samples1 , pairs=1000, each=1000, verbose=FALSE, direction=c("one.way", "two.way")){
  LOWER.BOUND <- 1e-6                   #just to help with optimization
  pos <- scan(paste(path.to.samples, "/pos.gz", sep=""), quiet=TRUE)
  map <- get.mapfn(map.file)
  n1 <- length(samples1)
  n2 <- length(samples2)
  l <- length(pos) 
  p1 <- sort(sample(n1, size=pairs, replace=TRUE))
  p2 <- sample(n2, size=pairs, replace=TRUE)

  results.l <- rep(0, pairs*each)
  results.r <- rep(0, pairs*each)

  if(verbose){cat("Estimating length overestimate parameters\n")}
  for(i in 1:pairs){
    while(p2[i]==p1[i]){p2[i] <- sample(n2, size=1)} #just in case we accidentally picked the same person. 
    if(verbose){cat(paste("\r", i, "/", pairs, sep="" ))}
    gt1 <- scan(paste( path.to.samples, "/", samples1[p1[i]], ".gt.gz", sep =""), quiet=TRUE, nmax=l)
    gt2 <- scan(paste( path.to.samples, "/", samples2[p2[i]], ".gt.gz", sep =""), quiet=TRUE, nmax=l)
    
    for(j in 1:each){
      x <- sample(min(pos):max(pos), size=1)
      pts <- find.inconsistent.hom(gt1, gt2, pos, x, l)
      ps <- pos[pts]
      results.l[pairs*(i-1)+j] <- map[x,"y"]-map[ps[1], "y"]
      results.r[pairs*(i-1)+j] <- map[ps[2], "y"]-map[x, "y"]
    }
  }
  if(verbose){cat("\n")}

  if(direction[1]=="one.way"){
    results <- ifelse(runif(pairs*each)<0.5, results.l, results.r) #r and l are correlated, so we want one sided only. 
    fit <- fitdistr(results[results>0], "gamma", lower=rep(LOWER.BOUND, 2))
    error.params <- fit$estimate
    error.params[1] <- error.params[1]*2  #double shape parameter since the overestimate is on both sides
  }else if(direction[1]=="two.way"){
    results <- results.l+results.r
    fit <- fitdistr(results[results>0], "gamma", lower=rep(LOWER.BOUND, 2))
    error.params <- fit$estimate
  }else{ stop("Don't recognise direction")}
  
  error.params[2] <- error.params[2]*100  #convert to Morgans
  return(error.params)
}

